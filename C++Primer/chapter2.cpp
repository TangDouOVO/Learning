/*
2.11
指出下面语句是声明还是定义
(1)extern int ix = 1024 定义
(2)int iy 声明
(3)extern int iz 声明

2.15
下面的哪个定义是不合法的？
(1)int ival = 1.01 √
(2)int & rval1 = 1.01 ×:引用必须指向一个实际存在的对象，而不是字面值常量
(3)int & rval2 = ival √
(4)int & rval3 ×：引用必须初始化 
 
2.16
下面哪些是合法的
int i = 0, &r1 = i; double d = 0, &r2 = d; 
(1)r2 = 3.1415926   √: 将 3.1415926 赋值给d 
(2)r2 = r1 √ 将i的值赋值给d 
(3)i = r2  √ 将d的值赋值给i 
(4)r1 = d  √ 将d的值赋值给i 

2.19
指针和引用的主要区别
（1）指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内它可以指向几个不同的对象；
引用不是一个对象，无法令引用重新绑定到另一个对象
（2）指针无须在定义时赋初值，和其他内置函数一样，在块的作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值；
引用则必须在定义时赋初值。 

2.21
下面哪些是合法的
int i = 0;
(1)double * dp = &i ×：类型不匹配 
(2)int * ip = i ×：不能直接将int变量赋给int指针，正确的做法是通过取地址运算&i得到变量i在内存中的地址，然后将地址赋值给指针 
(3)int* = = &i √

提示：在C++程序中，应该尽量初始化所有指针，并且尽可能等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，
就把它初始化为nullptr或是0，这样程序就能检测并知道它有没有指向一个具体的对象了。 

2.26
下面哪些是合法的
(1)const int buf ×：const对象必需要初始化 
(2)int cnt = 0 √ 
(3)const int sz = cnt √ 
(4)++cnt; ++sz; 错sz是一个const不能改变值 

2.27
下面哪些是合法的
(1)int i = -1, &r = 0; ×:引用必须指向一个实际存在的对象，而不是字面值常量
(2)int * const p2 = &i2; √：p2是一个常量指针 
(3)const int i = -1, &r = 0; √：r是一个常量引用，此时r可以绑定到字面值常量0 
(4)const int* const p3 = &i2; √：p3是一个常量指针，p3的值永远不变，即p3永远指向变量i2；同时，p3指向的是一个常量，即不能通过p3改变所指向对象的值 
(5)const int * p1 = &i2 √：p1指向一个常量，不能通过p1改变所指对象的值 
(6)const int & const r2 ×：引用本身不是对象，因此不能让引用恒定不变 
(7)const int i2 = i， &r = i; √

2.28
下面哪些是合法的
(1)int i, *const cp; ×：cp是一个常量指针必须初始化 
(2)int *p1, *const p2; ×：p2是一个常量指针必须初始化 
(3)const int ic, &r = ic; ×：ic是一个常量必须初始化  
(4)const int * cosnt p3；×：p3是一个常量指针，引起值不能改变，所以必须初始化；同时，p3指向的是常量，即我们不能通过p3改变所指对象的值 
(5)const int * p；

2.29
假设已有上一个练习中定义的那些变量，下面哪些是合法的
(1)i = ic √ 
(2)p1 = p3 ×：普通指针指向一个常量，从语法上说，p1的值可以随意改变，不合理 
(3)p1 = &ic ×：普通指针指向一个常量，从语法上说，p1的值可以随意改变，不合理 
(4)p3 = &ic ×：p3是一个常量指针，不能被赋值 
(5)p2 = &ic ×：p2是一个常量指针，不能被赋值 
(6)ic = *p3 ×：ic是一个常量不能被赋值

2.30
判断是顶层const还是底层const
(1)const int v2 顶层const 
(2)const int * p2 底层const
(3)const int *const p3 = &i顶层const 
(4)const int &r2 = v2 底层const
补充：名词顶层const表示指针本身是一个常量，而用名字底层const表示指针所指的对象是一个常量

2.38
auto和decltype的区别
（1）auto类型说明符用编辑器计算变量的初始值来推断其类型，而decltype虽然也让编辑器分析表达式并得到它的类型，但是不实际计算表达式的值 
（2）编辑器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会忽略
掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const 
（3）decltype的结果类型与表达式形式密切相关，如果变量名加上一对括号，则得到的类型与不加括号时会有不同。吐过decltype使用的是一个不加括号的变量，
则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将腿短得到引用类型。 
*/
